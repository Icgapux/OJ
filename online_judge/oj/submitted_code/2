/*
程序功能： 模拟自回避随机行走问题
作者：罗志涛
*/
#include<bits/stdc++.h>
#include<ctime>
#include <exception>

#define MaxSize 1000

using namespace std;

int visted[MaxSize][MaxSize];  //二维数组用来判断交叉路口是否经过，0表示没经过，1表示经过
const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

bool fun(int n,int &l)
{   
    memset(visted,0,sizeof visted);//初始时交叉路口都没经过
    int x = n/2;
    int y = n/2;            //开始狗在城市中心
    visted[x][y] = 1;       //置已经过标志
    l = 0;
    bool flag = 0;          //用来判断是否成功逃出
    while(1) //做无限循环，当成功或失败时跳出，否则模拟自回避随机行走
    {
        if(x == 0||x == n + 1||y == 0||y == n + 1)//判断是否成功逃出
        {
            flag = 1;
            break;
        }
        if(visted[x-1][y] && visted[x+1][y] && visted[x][y-1] && visted[x][y+1]) break;//判断是否陷入死胡同
        int rannum = rand() % 4;//生成一个范围在[0,3]的随机整数
        if (!visted[x+dx[rannum]][y+dy[rannum]]) 
        {
			x += dx[rannum];
			y += dy[rannum];
			visted[x][y] = 1;
			++l;
		}        
    }
    return flag;
}

int main()
{   
    srand(time(NULL));      //保证每次模拟生成的随机数不同
    int T,N;
    int defCount = 0;       //陷入死胡同的次数
    int lenall = 0;         //总路径长度
    int suslen = 0;         //成功逃出路径长度
    int deflen = 0;         //陷入死胡同路径长度
    printf("请输入狗尝试出逃次数：\n");
    scanf("%d",&T);//T表示测试次数
    printf("请输入城市规模大小：\n");
    scanf("%d",&N);//N表示问题规模
    for(int i = 1;i <= T;i++)
    {
        int len = 0;
        int flag = fun(N,len);
        lenall += len;
        if(flag)
        {
            suslen += len;
        }
        else
        {
            deflen += len;
            defCount ++;
        } 
    }
    printf("狗陷入死胡同概率：%.2lf%%\n",100.0 * defCount / T);
    printf("行走路径的平均长度：%d\n",lenall / T);
    printf("成功逃出的平均路径长度：%d\n",suslen / T);
    printf("陷入死胡同的平均路径长度：%d\n",deflen / T);

    return 0;
}

